import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import ExcelJS from 'exceljs';
import { format as formatDate } from 'date-fns';

// Helper functions for professional Excel formatting
const capitalizeWords = (str: string) => {
  if (!str) return '';
  return str.split(' ').map(word => 
    word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
  ).join(' ');
};

const formatStatusText = (status: string) => {
  if      // Now add the data table header row with professional styling optimized for sorting (matching main reports)
      const headerRow = worksheet.addRow(exportHeaders);
      headerRow.height = 35; // Increased height for better presentation with sort arrows
      
      headerRow.eachCell((cell, colNumber) => {
        cell.font = { bold: true, color: { argb: 'FFFFFF' }, size: 12, name: 'Arial' }; // Increased font size
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: '1F4E79' } // Dark blue color
        };
        cell.border = {
          top: { style: 'medium', color: { argb: '1F4E79' } }, // Thicker borders
          left: { style: 'medium', color: { argb: '1F4E79' } },
          bottom: { style: 'medium', color: { argb: '1F4E79' } },
          right: { style: 'medium', color: { argb: '1F4E79' } }
        };
        
        // Apply center alignment to ALL headers, especially Description
        cell.alignment = { 
          horizontal: 'center', 
          vertical: 'middle',
          wrapText: true
        };
      });

const formatStatusText = (status: string) => {
  if (!status) return 'Unknown';
  return status.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};

const preserveDescriptionFormatting = (description: string | null) => {
  if (!description) return 'N/A';
  // Remove HTML tags but preserve line breaks and basic formatting
  return description
    .replace(/<br\s*\/?>/gi, '\n')
    .replace(/<\/p>/gi, '\n')
    .replace(/<p>/gi, '')
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .trim();
};

const getTechnicianName = (technician: any) => {
  if (!technician || !technician.name) return 'Unassigned';
  return capitalizeWords(technician.name);
};

const formatDateDisplay = (date: Date | string | null) => {
  if (!date) return 'N/A';
  try {
    return formatDate(new Date(date), 'MMMM dd, yyyy');
  } catch (error) {
    return 'Invalid Date';
  }
};

export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    if (!session.user.isTechnician) {
      return NextResponse.json({ error: "Access denied. Technician access required." }, { status: 403 });
    }

    const userId = parseInt(session.user.id.toString());

    const { searchParams } = new URL(request.url);
    const exportFormat = searchParams.get('export') || 'excel'; // Default to Excel
    
    // Support both parameter structures for compatibility
    const fields = searchParams.get('fields')?.split(',') || [];
    
    // Main reports API compatible parameters
    const requestType = searchParams.get('requestType');
    const requestStatus = searchParams.get('requestStatus');
    const approvalStatus = searchParams.get('approvalStatus'); 
    const mode = searchParams.get('mode');
    const requesterId = searchParams.get('requesterId');
    const departmentId = searchParams.get('departmentId');
    const createdTimeFrom = searchParams.get('createdTimeFrom');
    const createdTimeTo = searchParams.get('createdTimeTo');
    const dueByTimeFrom = searchParams.get('dueByTimeFrom');
    const dueByTimeTo = searchParams.get('dueByTimeTo');
    const resolvedTimeFrom = searchParams.get('resolvedTimeFrom');
    const resolvedTimeTo = searchParams.get('resolvedTimeTo');
    const priority = searchParams.get('priority');
    const technicianId = searchParams.get('technicianId');
    const serviceCategoryId = searchParams.get('serviceCategoryId');
    const templateId = searchParams.get('templateId');
    const searchRequestId = searchParams.get('searchRequestId');
    const searchSubject = searchParams.get('searchSubject');
    
    // Legacy parameters for backward compatibility
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');
    const status = searchParams.get('status')?.split(',');
    const legacyApprovalStatus = searchParams.get('approvalStatus')?.split(',');
    const searchTerm = searchParams.get('search');

    if (!['csv', 'json', 'excel'].includes(exportFormat)) {
      return NextResponse.json({ error: "Invalid format. Must be 'csv', 'json', or 'excel'" }, { status: 400 });
    }

    // Allow export even without selected fields (will use default field set)
    const defaultFields = fields.length === 0 ? [
      'requestId', 'requestSubject', 'requestDescription', 'requestType', 'requestStatus', 
      'requester', 'department', 'priority', 'createdTime', 'technician'
    ] : fields;

    // Build the where clause (matching main reports API exactly)
    const whereClause: any = {};

    // Handle date filters (prioritize main reports API parameters)
    const effectiveStartDate = createdTimeFrom || startDate;
    const effectiveEndDate = createdTimeTo || endDate;
    
    if (effectiveStartDate || effectiveEndDate) {
      whereClause.createdAt = {};
      if (effectiveStartDate) {
        whereClause.createdAt.gte = new Date(effectiveStartDate);
      }
      if (effectiveEndDate) {
        whereClause.createdAt.lte = new Date(effectiveEndDate + 'T23:59:59.999Z');
      }
    }

    // Handle status filters
    const effectiveStatus = requestStatus || (status && status.length > 0 ? status : null);
    if (effectiveStatus) {
      if (Array.isArray(effectiveStatus)) {
        whereClause.status = { in: effectiveStatus };
      } else {
        whereClause.status = effectiveStatus;
      }
    }

    if (searchTerm) {
      whereClause.OR = [
        {
          user: {
            emp_fname: {
              contains: searchTerm,
              mode: 'insensitive'
            }
          }
        },
        {
          user: {
            emp_lname: {
              contains: searchTerm,
              mode: 'insensitive'
            }
          }
        }
      ];
    }

    if (approvalStatus && approvalStatus.length > 0) {
      whereClause.approvals = {
        some: {
          status: {
            in: approvalStatus
          }
        }
      };
    }

    // Fetch the data
    const requests = await prisma.request.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            emp_fname: true,
            emp_lname: true,
            emp_mid: true,
            department: true,
            emp_email: true
          }
        },
        approvals: {
          include: {
            approver: {
              select: {
                id: true,
                emp_fname: true,
                emp_lname: true,
                emp_email: true
              }
            }
          },
          orderBy: {
            createdAt: 'desc'
          }
        },
        history: {
          where: {
            action: 'resolved'
          },
          orderBy: {
            timestamp: 'desc'
          },
          take: 1
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    // Get templates
    const templateIds = Array.from(new Set(requests.map(r => r.templateId)));
    const templates = await prisma.template.findMany({
      where: {
        id: {
          in: templateIds.map(id => parseInt(id))
        }
      },
      include: {
        category: {
          select: {
            name: true
          }
        }
      }
    });

    const templateMap = new Map(templates.map(t => [t.id.toString(), t]));

    // Define field labels
    const fieldLabels: { [key: string]: string } = {
      requestId: 'Request ID',
      templateName: 'Template/Service',
      requesterName: 'Requester Name',
      requesterDepartment: 'Requester Department',
      assignedTechnician: 'Assigned Technician',
      supportGroup: 'Support Group',
      priority: 'Priority',
      status: 'Status',
      createdAt: 'Created Date',
      updatedAt: 'Last Updated',
      closedAt: 'Closed Date',
      slaBreached: 'SLA Breached',
      resolutionTime: 'Resolution Time',
      approvalStatus: 'Approval Status',
      approvedBy: 'Approved By',
      description: 'Description',
      category: 'Category'
    };

    // Format the data
    const formattedData = requests.map(request => {
      const record: any = {};
      const template = templateMap.get(request.templateId);

      defaultFields.forEach(field => {
        const label = fieldLabels[field] || field;
        
        switch (field) {
          case 'requestId':
            record[label] = request.id.toString();
            break;
          case 'requestSubject':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              // Extract subject from formData field 8, fallback to template name (matching main reports API)
              record[label] = (formData as any)?.['8'] || (formData as any)?.subject || template?.name || `Request #${request.id}`;
            } catch {
              record[label] = template?.name || `Request #${request.id}`;
            }
            break;
          case 'requestDescription':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              // Extract description from formData field 9 (matching main reports API)
              const desc = (formData as any)?.['9'] || (formData as any)?.description || (formData as any)?.details || (formData as any)?.issueDescription || '';
              record[label] = desc.length > 200 ? desc.substring(0, 200) + '...' : desc;
            } catch {
              record[label] = '';
            }
            break;
          case 'requestType':
            record[label] = template?.type || 'Service';
            break;
          case 'requestStatus':
            record[label] = request.status || '';
            break;
          case 'templateName':
            record[label] = template?.name || '-';
            break;
          case 'requesterName':
          case 'requester':
            const fullName = [
              request.user.emp_fname,
              request.user.emp_mid,
              request.user.emp_lname
            ].filter(Boolean).join(' ');
            record[label] = fullName || '-';
            break;
          case 'requesterDepartment':
          case 'department':
            record[label] = request.user.department || '-';
            break;
          case 'assignedTechnician':
          case 'technician':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              // Match main reports API technician field extraction
              const technicianName = (request as any).assignedTechnician || 
                                    (formData as any)?.assignedTechnician ||
                                    (formData as any)?.assignedTechnicianName || 
                                    (formData as any)?.['assigned technician'] ||
                                    (formData as any)?.assigned_technician || 
                                    (formData as any)?.assignedTo ||
                                    (formData as any)?.technician ||
                                    null;
              
              record[label] = technicianName && technicianName.toString().trim() !== '' 
                ? technicianName.toString().trim() 
                : 'Unassigned';
            } catch {
              record[label] = 'Unassigned';
            }
            break;
          case 'supportGroup':
            record[label] = '-';
            break;
          case 'priority':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              // Extract priority from formData field 2, matching main reports API
              let priority = 'Medium'; // Default value
              if ((formData as any)?.['2']) {
                priority = (formData as any)['2'];
              } else if ((formData as any)?.priority) {
                priority = (formData as any).priority;
              } else {
                // Try to find priority in any field that might contain it
                const priorityFields = Object.keys(formData || {}).filter(key => 
                  key.toLowerCase().includes('priority') ||
                  String((formData as any)[key]).toLowerCase().match(/^(low|medium|high|critical)$/i)
                );
                if (priorityFields.length > 0) {
                  priority = (formData as any)[priorityFields[0]];
                }
              }
              record[label] = priority;
            } catch {
              record[label] = 'Medium';
            }
            break;
          case 'status':
            record[label] = request.status?.replace('_', ' ').toUpperCase() || '-';
            break;
          case 'createdAt':
          case 'createdTime':
            record[label] = request.createdAt ? new Date(request.createdAt).toLocaleDateString('en-US', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            }) : '';
            break;
          case 'updatedAt':
            record[label] = request.updatedAt.toLocaleDateString();
            break;
          case 'closedAt':
          case 'resolvedTime':
            const resolvedDate = request.history[0]?.timestamp;
            record[label] = resolvedDate ? new Date(resolvedDate).toLocaleDateString('en-US', {
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit'
            }) : '';
            break;
          case 'dueByTime':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              const dueDate = (formData as any)?.due_date;
              record[label] = dueDate ? new Date(dueDate).toLocaleDateString('en-US', {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
              }) : '';
            } catch {
              record[label] = '';
            }
            break;
          case 'slaBreached':
            record[label] = 'No';
            break;
          case 'resolutionTime':
            if (request.history[0]?.timestamp && request.createdAt) {
              const resolutionTimeMs = request.history[0].timestamp.getTime() - request.createdAt.getTime();
              const hours = Math.floor(resolutionTimeMs / (1000 * 60 * 60));
              const minutes = Math.floor((resolutionTimeMs % (1000 * 60 * 60)) / (1000 * 60));
              record[label] = `${hours}h ${minutes}m`;
            } else {
              record[label] = '-';
            }
            break;
          case 'approvalStatus':
            const latestApproval = request.approvals[0];
            record[label] = latestApproval?.status?.replace('_', ' ').toUpperCase() || 'N/A';
            break;
          case 'approvedBy':
            const approver = request.approvals.find((a: any) => a.status === 'approved')?.approver;
            const approverName = approver ? `${approver.emp_fname} ${approver.emp_lname}` : '-';
            record[label] = approverName;
            break;
          case 'description':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              const desc = (formData as any)?.description || (formData as any)?.summary || (formData as any)?.issue || '-';
              record[label] = desc.length > 100 ? desc.substring(0, 100) + '...' : desc;
            } catch {
              record[label] = '-';
            }
            break;
          case 'category':
          case 'serviceCategory':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              record[label] = (formData as any)?.category || template?.category?.name || '';
            } catch {
              record[label] = template?.category?.name || '';
            }
            break;
          case 'requestTemplate':
            record[label] = template?.name || '';
            break;
          case 'sla':
            record[label] = template?.slaServiceId ? `SLA ${template.slaServiceId}` : 'Standard SLA';
            break;
          case 'mode':
            try {
              const formData = typeof request.formData === 'string' ? JSON.parse(request.formData) : request.formData;
              record[label] = (formData as any)?.mode || 'Online';
            } catch {
              record[label] = 'Online';
            }
            break;
          default:
            record[label] = '-';
        }
      });

      return record;
    });

    if (exportFormat === 'excel') {
      // Create professional Excel workbook with advanced formatting
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet('Technician Reports', {
        pageSetup: {
          paperSize: 9,
          orientation: 'landscape',
          fitToPage: true,
          fitToWidth: 1,
          fitToHeight: 0
        }
      });

      // Professional Excel headers matching main reports
      const exportHeaders = defaultFields.map(field => fieldLabels[field] || field);

      // Add professional header section matching main reports exactly
      // Set up worksheet properties
      worksheet.properties.defaultRowHeight = 20;
      worksheet.views = [{ showGridLines: false }];
      
      // Set standard column width
      worksheet.getColumn(1).width = 30;

      // Row 1: IT HELPDESK SYSTEM left-aligned with improved styling
      const systemRow = worksheet.addRow(['IT HELPDESK SYSTEM']);
      systemRow.getCell(1).font = { size: 12, bold: true, color: { argb: '000000' }, name: 'Arial' };
      systemRow.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
      systemRow.height = 25;

      // Row 2: IT Helpdesk Export Report with improved styling  
      const titleRow = worksheet.addRow(['IT Helpdesk Export Report']);
      titleRow.getCell(1).font = { size: 11, bold: false, color: { argb: '555555' }, name: 'Arial' };
      titleRow.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
      titleRow.height = 22;

      // Row 3: Generated info
      const currentDate = new Date();
      const userName = session?.user?.name || 'System Administrator';
      
      const infoRow1 = worksheet.addRow([`Generated: ${currentDate.toLocaleDateString()} at ${currentDate.toLocaleTimeString()}`]);
      infoRow1.getCell(1).font = { size: 10, color: { argb: '6B7280' }, name: 'Arial' };
      infoRow1.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
      infoRow1.height = 20;
      
      // Row 4: Exported by info  
      const infoRow2 = worksheet.addRow([`Exported by: ${userName} | Total Records: ${formattedData.length}`]);
      infoRow2.getCell(1).font = { size: 10, color: { argb: '6B7280' }, name: 'Arial' };
      infoRow2.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
      infoRow2.height = 20;

      // Row 5: Applied Filters - matching main reports format
      const appliedFilters = [];
      
      // Build filter description exactly like main reports
      if (requestType) appliedFilters.push(`Request Type: ${capitalizeWords(requestType)}`);
      if (requestStatus || effectiveStatus) {
        const status = requestStatus || (Array.isArray(effectiveStatus) ? effectiveStatus.join(', ') : effectiveStatus);
        appliedFilters.push(`Status: ${formatStatusText(status)}`);
      }
      if (approvalStatus) appliedFilters.push(`Approval: ${formatStatusText(approvalStatus)}`);
      if (mode) appliedFilters.push(`Mode: ${capitalizeWords(mode)}`);
      if (priority) appliedFilters.push(`Priority: ${capitalizeWords(priority)}`);
      if (departmentId) {
        const deptName = formattedData.length > 0 ? formattedData[0]['Department'] || 'Selected Department' : 'Selected Department';
        appliedFilters.push(`Department: ${deptName}`);
      }
      if (createdTimeFrom || effectiveStartDate || createdTimeTo || effectiveEndDate) {
        let dateRange = 'Created: ';
        const startDate = createdTimeFrom || effectiveStartDate;
        const endDate = createdTimeTo || effectiveEndDate;
        if (startDate && endDate) {
          dateRange += `${formatDateDisplay(startDate)} to ${formatDateDisplay(endDate)}`;
        } else if (startDate) {
          dateRange += `From ${formatDateDisplay(startDate)}`;
        } else if (endDate) {
          dateRange += `Until ${formatDateDisplay(endDate)}`;
        }
        appliedFilters.push(dateRange);
      }
      if (dueByTimeFrom || dueByTimeTo) {
        let dateRange = 'Due By: ';
        if (dueByTimeFrom && dueByTimeTo) {
          dateRange += `${formatDateDisplay(dueByTimeFrom)} to ${formatDateDisplay(dueByTimeTo)}`;
        } else if (dueByTimeFrom) {
          dateRange += `From ${formatDateDisplay(dueByTimeFrom)}`;
        } else if (dueByTimeTo) {
          dateRange += `Until ${formatDateDisplay(dueByTimeTo)}`;
        }
        appliedFilters.push(dateRange);
      }
      if (resolvedTimeFrom || resolvedTimeTo) {
        let dateRange = 'Resolved: ';
        if (resolvedTimeFrom && resolvedTimeTo) {
          dateRange += `${formatDateDisplay(resolvedTimeFrom)} to ${formatDateDisplay(resolvedTimeTo)}`;
        } else if (resolvedTimeFrom) {
          dateRange += `From ${formatDateDisplay(resolvedTimeFrom)}`;
        } else if (resolvedTimeTo) {
          dateRange += `Until ${formatDateDisplay(resolvedTimeTo)}`;
        }
        appliedFilters.push(dateRange);
      }
      if (searchRequestId) appliedFilters.push(`Request ID: "${searchRequestId}"`);
      if (searchSubject || searchTerm) appliedFilters.push(`Search: "${searchSubject || searchTerm}"`);
      
      // Add filters row if any filters are applied
      let filtersRow;
      if (appliedFilters.length > 0) {
        const filterText = `Applied Filters: ${appliedFilters.join(' | ')}`;
        filtersRow = worksheet.addRow([filterText]);
        filtersRow.getCell(1).font = { size: 10, color: { argb: '059669' }, bold: true, name: 'Arial' }; // Green text for filters
        filtersRow.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
        filtersRow.height = 20;
      } else {
        filtersRow = worksheet.addRow(['Applied Filters: None (All records)']);
        filtersRow.getCell(1).font = { size: 10, color: { argb: '6B7280' }, name: 'Arial' }; // Gray text
        filtersRow.getCell(1).alignment = { horizontal: 'left', vertical: 'middle' };
        filtersRow.height = 20;
      }

      // Professional table header row
      const headerRow = worksheet.addRow(exportHeaders);
      headerRow.height = 35;
      
      headerRow.eachCell((cell, colNumber) => {
        cell.font = { bold: true, color: { argb: 'FFFFFF' }, size: 12, name: 'Arial' };
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: '1F4E79' }
        };
        cell.border = {
          top: { style: 'medium', color: { argb: '1F4E79' } },
          left: { style: 'medium', color: { argb: '1F4E79' } },
          bottom: { style: 'medium', color: { argb: '1F4E79' } },
          right: { style: 'medium', color: { argb: '1F4E79' } }
        };
        cell.alignment = { 
          horizontal: 'center', 
          vertical: 'middle',
          wrapText: true
        };
      });

      // Add data rows with professional formatting
      formattedData.forEach((record, index) => {
        const values = exportHeaders.map(header => record[header] || '');
        const row = worksheet.addRow(values);

        // Calculate row height based on content
        const maxLines = Math.max(
          ...values.map(value => {
            const str = String(value || '');
            const lines = (str.match(/\n/g) || []).length + 1;
            const wrapLines = Math.ceil(str.length / 60);
            return Math.max(lines, wrapLines);
          }),
          1
        );
        
        row.height = Math.min(Math.max(25 + ((maxLines - 1) * 18), 30), 200);

        // Apply professional styling to each cell
        row.eachCell((cell, colNumber) => {
          cell.font = { size: 9, color: { argb: '000000' }, name: 'Arial' };
          cell.fill = {
            type: 'pattern',
            pattern: 'solid',
            fgColor: { argb: 'FFFFFF' }
          };
          cell.border = {
            top: { style: 'thin', color: { argb: 'D1D5DB' } },
            left: { style: 'thin', color: { argb: 'D1D5DB' } },
            bottom: { style: 'thin', color: { argb: 'D1D5DB' } },
            right: { style: 'thin', color: { argb: 'D1D5DB' } }
          };
          cell.alignment = { 
            horizontal: 'center', 
            vertical: 'middle',
            wrapText: true
          };

          // Special formatting for specific field types
          const fieldName = defaultFields[colNumber - 1];
          const value = String(cell.value || '');
          
          if (fieldName === 'requestId') {
            cell.font = { size: 9, color: { argb: '2563EB' }, bold: true };
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
          } else if (fieldName === 'templateName' || fieldName === 'requestSubject') {
            cell.font = { size: 9, color: { argb: '2563EB' }, underline: true };
            cell.alignment = { horizontal: 'left', vertical: 'top', wrapText: true };
          } else if (fieldName === 'description' || fieldName === 'requestDescription') {
            cell.font = { size: 9, color: { argb: '374151' }, name: 'Arial' };
            cell.alignment = { horizontal: 'left', vertical: 'top', wrapText: true, indent: 1 };
          } else if (fieldName === 'priority') {
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
            const priority = value.toLowerCase();
            if (priority === 'high' || priority === 'critical') {
              cell.font = { size: 9, color: { argb: 'DC2626' }, bold: true };
            } else if (priority === 'medium') {
              cell.font = { size: 9, color: { argb: 'D97706' }, bold: true };
            } else if (priority === 'low') {
              cell.font = { size: 9, color: { argb: '059669' }, bold: true };
            }
          } else if (fieldName === 'status' || fieldName === 'requestStatus' || fieldName === 'approvalStatus') {
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
          } else if (fieldName.includes('Date') || fieldName.includes('Time') || fieldName.includes('At')) {
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
          }
        });
      });

      // Auto-adjust column widths
      const columnSettings = exportHeaders.map((header, index) => {
        const fieldName = defaultFields[index];
        if (fieldName === 'requestId') return { min: 10, autoWidth: true };
        if (fieldName === 'templateName' || fieldName === 'requestSubject') return { min: 25, autoWidth: true };
        if (fieldName === 'description' || fieldName === 'requestDescription') return { min: 40, autoWidth: true };
        if (fieldName === 'requesterName' || fieldName === 'requester') return { min: 20, autoWidth: true };
        if (fieldName === 'assignedTechnician' || fieldName === 'technician') return { min: 18, autoWidth: true };
        if (fieldName.includes('Date') || fieldName.includes('Time')) return { min: 15, autoWidth: true };
        return { min: 15, autoWidth: true };
      });

      columnSettings.forEach((setting, index) => {
        const column = worksheet.getColumn(index + 1);
        let maxLength = setting.min;
        
        column.eachCell({ includeEmpty: false }, (cell) => {
          if (cell.value) {
            const cellValue = cell.value.toString();
            if (defaultFields[index] === 'description' || defaultFields[index] === 'requestDescription') {
              const lines = cellValue.split('\n');
              const longestLine = Math.max(...lines.map(line => line.length));
              maxLength = Math.max(maxLength, Math.min(longestLine + 5, 80));
            } else {
              maxLength = Math.max(maxLength, cellValue.length + 3);
            }
          }
        });
        
        column.width = maxLength;
      });

      // Add AutoFilter for sorting capability
      const headerRowNumber = 6;
      const lastDataRow = headerRowNumber + formattedData.length;
      const lastColumn = exportHeaders.length;
      
      if (formattedData.length > 0) {
        worksheet.autoFilter = {
          from: { row: headerRowNumber, column: 1 },
          to: { row: lastDataRow, column: lastColumn }
        };
      }

      // Generate Excel buffer
      const buffer = await workbook.xlsx.writeBuffer();

      return new NextResponse(buffer, {
        headers: {
          'Content-Disposition': `attachment; filename="ASPAC_Technician_Report_${new Date().toISOString().split('T')[0]}.xlsx"`,
          'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        },
      });
    } else if (exportFormat === 'csv') {
      // Create CSV content
      const headers = fields.map(field => fieldLabels[field] || field);
      const csvRows = [headers.join(',')];
      
      formattedData.forEach(row => {
        const values = headers.map(header => {
          const value = row[header] || '';
          // Escape commas and quotes in CSV
          return `"${value.toString().replace(/"/g, '""')}"`;
        });
        csvRows.push(values.join(','));
      });
      
      const csvContent = csvRows.join('\n');
      
      return new NextResponse(csvContent, {
        headers: {
          'Content-Type': 'text/csv',
          'Content-Disposition': `attachment; filename="technician-report-${new Date().toISOString().split('T')[0]}.csv"`
        }
      });
    } else if (exportFormat === 'json') {
      // Return JSON format
      const jsonContent = {
        metadata: {
          generatedAt: new Date().toISOString(),
          totalRecords: formattedData.length,
          fields: fields,
          filters: {
            startDate,
            endDate,
            status,
            approvalStatus,
            searchTerm
          }
        },
        data: formattedData
      };
      
      return new NextResponse(JSON.stringify(jsonContent, null, 2), {
        headers: {
          'Content-Type': 'application/json',
          'Content-Disposition': `attachment; filename="technician-report-${new Date().toISOString().split('T')[0]}.json"`
        }
      });
    }

    return NextResponse.json({ error: "Invalid format" }, { status: 400 });

  } catch (error) {
    console.error("Error exporting report:", error);
    return NextResponse.json(
      { error: "Failed to export report" },
      { status: 500 }
    );
  }
}
